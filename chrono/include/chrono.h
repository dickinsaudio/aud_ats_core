//
// AUDIO TEMPORAL STRETCHER CODE LICENSE
//
// PERMISION NOTICE
//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//
//
// 1.   Subject to the terms and conditions of this Licence, Audinate hereby grants you a worldwide, non-exclusive, 
//      no-charge, royalty free licence to copy, modify, merge, publish, redistribute, sublicense, and/or sell the 
//      Software, provided always that the following conditions are met: 
//      1.1.    the Software must accompany, or be incorporated in a licensed Audinate product, solution or offering 
//              or be used in a product, solution or offering which requires the use of another licensed Audinate 
//              product, solution or offering. The Software is not for use as a standalone product without any 
//              reference to Audinate’s products;
//      1.2.    the Software is provided as part of example code and as guidance material only without any warranty 
//              or expectation of performance, compatibility, support, updates or security; and
//      1.3.    the above copyright notice and this License must be included in all copies or substantial portions 
//              of the Software, and all derivative works of the Software, unless the copies or derivative works are 
//              solely in the form of machine-executable object code generated by the source language processor.
//
// 2.   TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
//      XPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
//      PURPOSE AND NONINFRINGEMENT. 
//
// 3.   TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL AUDINATE BE LIABLE ON ANY LEGAL THEORY 
//      (INCLUDING, WITHOUT LIMITATION, IN AN ACTION FOR BREACH OF CONTRACT, NEGLIGENCE OR OTHERWISE) FOR ANY CLAIM, 
//      LOSS, DAMAGES OR OTHER LIABILITY HOWSOEVER INCURRED.  WITHOUT LIMITING THE SCOPE OF THE PREVIOUS SENTENCE THE 
//      EXCLUSION OF LIABILITY SHALL INCLUDE: LOSS OF PRODUCTION OR OPERATION TIME, LOSS, DAMAGE OR CORRUPTION OF 
//      DATA OR RECORDS; OR LOSS OF ANTICIPATED SAVINGS, OPPORTUNITY, REVENUE, PROFIT OR GOODWILL, OR OTHER ECONOMIC 
//      LOSS; OR ANY SPECIAL, INCIDENTAL, INDIRECT, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES, ARISING OUT OF OR 
//      IN CONNECTION WITH THIS AGREEMENT, ACCESS OF THE SOFTWARE OR ANY OTHER DEALINGS WITH THE SOFTWARE, EVEN IF 
//      AUDINATE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH CLAIM, LOSS, DAMAGES OR OTHER LIABILITY.
//
// 4.   APPLICABLE LEGISLATION SUCH AS THE AUSTRALIAN CONSUMER LAW MAY APPLY REPRESENTATIONS, WARRANTIES, OR CONDITIONS, 
//      OR IMPOSES OBLIGATIONS OR LIABILITY ON AUDINATE THAT CANNOT BE EXCLUDED, RESTRICTED OR MODIFIED TO THE FULL 
//      EXTENT SET OUT IN THE EXPRESS TERMS OF THIS CLAUSE ABOVE "CONSUMER GUARANTEES".  TO THE EXTENT THAT SUCH CONSUMER 
//      GUARANTEES CONTINUE TO APPLY, THEN TO THE FULL EXTENT PERMITTED BY THE APPLICABLE LEGISLATION, THE LIABILITY OF 
//      AUDINATE UNDER THE RELEVANT CONSUMER GUARANTEE IS LIMITED (WHERE PERMITTED AT AUDINATE’S OPTION) TO ONE OF 
//      FOLLOWING REMEDIES OR SUBSTANTIALLY EQUIVALENT REMEDIES:
//      4.1.    THE REPLACEMENT OF THE SOFTWARE, THE SUPPLY OF EQUIVALENT SOFTWARE, OR SUPPLYING RELEVANT SERVICES AGAIN;
//      4.2.    THE REPAIR OF THE SOFTWARE;
//      4.3.    THE PAYMENT OF THE COST OF REPLACING THE SOFTWARE, OF ACQUIRING EQUIVALENT SOFTWARE, HAVING THE RELEVANT 
//              SERVICES SUPPLIED AGAIN, OR HAVING THE SOFTWARE REPAIRED.
//
// 5.   This License does not grant any permissions or rights to use the trade marks (whether registered or unregistered), 
//      the trade names, or product names of Audinate. 
//
// 6.   If you choose to redistribute or sell the Software you may elect to offer support, maintenance, warranties, 
//      indemnities or other liability obligations or rights consistent with this License. However, you may only act on 
//      your own behalf and must not bind Audinate. You agree to indemnify and hold harmless Audinate, and its affiliates 
//      form any liability claimed or incurred by reason of your offering or accepting any additional warranty or additional 
//      liability. 
//
// chrono.h
//

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CHRONOMETER BLOCK
//
// This is a useful structure for keeping data (histogram) of times for an event.
// This implementation of chronometer is intended to be very lean.  This is similar but does not use diretly hist
// since we want to embed the implementation of the time stamp closer in this to make it lean.  The data strucutre
// is quite compatible and we have a mapping to hist, so that the helper functions for hist can be used
//
// To manage precision timing with counter resolution and potentially long times, we use 64bit representations
// of counters.  It is required that this counter have a fixed frequency.
// The bins are uint32 so a limit of 4 billion events per time bin.
// The overall event count is 64 bit to enable any overflow to be detected.
// Bin widths are limited to uni32_t which is 400s for the 100ns typical timer.
//
// The binning from time events applies a dither to improve linearity and convergence of statistics
// extracted from the bins.  The start time and event count is also kept.  Binning is based on a bin0,
// width and number of bins.  The width must be integral so the range of the histogram will be quantized
// at very high resolution time binning.  Data use is around 40 bytes plus the histogram bins (int32_t).
//
#pragma once
#include "hist.h"
#include <stdint.h>
#include <time.h>

namespace Audinate { namespace chrono {

using namespace Audinate::hist;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// WORKER SIDE FUNCTIONS AND IMPLEMENTATION - DETAILS ABSTRACTED
//
// Setup a lean profiling histogram that keeps track of latest call times and runs a histogram specified by
// a zero time, bin width and number of bins.  The implementation is low MIP and the main memeory usage will
// depend on the number of histogram bins with about 40 bytes overhead.
//
// Note that in some implementations, the actual histogram will vary from that requested in the
// chronoConfig function due to rounding or optimizations.  Access the data using the hist
// mapping rather than assume anything in the setup.
//

struct chrono_t; // Abstract the implementation

class Chrono
{
  public:
    static uint64_t nowNs(); // Return the full time in ns - cast to uint32 to get the 32 bit rolling
    static timespec now();   // Return now at same offset

    Chrono();
    ~Chrono();

    bool config(
        float       bin0,                          // The centre of the first bin (s)
        float       binN,                          // The centre of the last bin (s)
        int         bins  = 101,                   // The number of bins to accumulate into, must be even - for example for 4 bins
        HistFlag    flags = HistFlag::DITHER,      // Additional flags, shared with hist
        const char *name  = nullptr);               // Optional name
    void reset();                                  // Reset without changing the config - use sparingly
    void event(uint64_t nowNs = 0, int count = 1); // Register an event, creating histogram of the time gaps
    void count(int val, int count = 1);            // Register a value, creating histogram of the values
    void restart();                                // Reset the last time so we can count a discontinuous interval

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // FUNCTIONS FOR ACCESSING THE DATA - PLATFORM INDEPENDENT
    //
    // Note that these timespecs are not necessarily offset from any origin

    int32_t configCount(); // Number of time it has been reset/configured
    int64_t eventCount();  // The number of events - use to bracket valid read

    timespec startTime(); // Return time the last config/reset occurred
    timespec lastTime();  // Return the last event time

    int64_t diffNs();   // Return the last time difference between events (ns)
    int64_t sinceNs();  // Return the time since the event last happened without triggering event
    int64_t periodNs(); // Return the longtime average period (ns)

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // ACCESSING THE HISTOGRAM
    //
    // For this we use hist.  This method will use an existing histogram instance doing a configure
    // which will resize any internal storage if needed.
    //
    void histogram(Histogram *h);

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Versions
    static unsigned int versionMajor();
    static unsigned int versionMinor();
    static unsigned int versionPatch();
    static const char * versionSuffix();
    static const char * versionHash();
    static const char * versionFull();

  private:
    uint32_t rand();                                // A 32 bit random number seeded within this chrono - may optimize to nothing
    char mData[64 + 4 + 4 + 8 + 8 + 8 + 8 + 8 + 4 + 4 + 101 * 4 + 4];
    // @Alan - is there a convenient way of doing this without exposing struct?
    // Note that the config has an assert to ensure this is correct size
};

}} // namespace Audinate::chrono

//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//