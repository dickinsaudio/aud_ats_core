//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//
//
// 1.   Subject to the terms and conditions of this Licence, Audinate hereby grants you a worldwide, non-exclusive, 
//      no-charge, royalty free licence to copy, modify, merge, publish, redistribute, sublicense, and/or sell the 
//      Software, provided always that the following conditions are met: 
//      1.1.    the Software must accompany, or be incorporated in a licensed Audinate product, solution or offering 
//              or be used in a product, solution or offering which requires the use of another licensed Audinate 
//              product, solution or offering. The Software is not for use as a standalone product without any 
//              reference to Audinate’s products;
//      1.2.    the Software is provided as part of example code and as guidance material only without any warranty 
//              or expectation of performance, compatibility, support, updates or security; and
//      1.3.    the above copyright notice and this License must be included in all copies or substantial portions 
//              of the Software, and all derivative works of the Software, unless the copies or derivative works are 
//              solely in the form of machine-executable object code generated by the source language processor.
//
// 2.   TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
//      XPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
//      PURPOSE AND NONINFRINGEMENT. 
//
// 3.   TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL AUDINATE BE LIABLE ON ANY LEGAL THEORY 
//      (INCLUDING, WITHOUT LIMITATION, IN AN ACTION FOR BREACH OF CONTRACT, NEGLIGENCE OR OTHERWISE) FOR ANY CLAIM, 
//      LOSS, DAMAGES OR OTHER LIABILITY HOWSOEVER INCURRED.  WITHOUT LIMITING THE SCOPE OF THE PREVIOUS SENTENCE THE 
//      EXCLUSION OF LIABILITY SHALL INCLUDE: LOSS OF PRODUCTION OR OPERATION TIME, LOSS, DAMAGE OR CORRUPTION OF 
//      DATA OR RECORDS; OR LOSS OF ANTICIPATED SAVINGS, OPPORTUNITY, REVENUE, PROFIT OR GOODWILL, OR OTHER ECONOMIC 
//      LOSS; OR ANY SPECIAL, INCIDENTAL, INDIRECT, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES, ARISING OUT OF OR 
//      IN CONNECTION WITH THIS AGREEMENT, ACCESS OF THE SOFTWARE OR ANY OTHER DEALINGS WITH THE SOFTWARE, EVEN IF 
//      AUDINATE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH CLAIM, LOSS, DAMAGES OR OTHER LIABILITY.
//
// 4.   APPLICABLE LEGISLATION SUCH AS THE AUSTRALIAN CONSUMER LAW MAY APPLY REPRESENTATIONS, WARRANTIES, OR CONDITIONS, 
//      OR IMPOSES OBLIGATIONS OR LIABILITY ON AUDINATE THAT CANNOT BE EXCLUDED, RESTRICTED OR MODIFIED TO THE FULL 
//      EXTENT SET OUT IN THE EXPRESS TERMS OF THIS CLAUSE ABOVE "CONSUMER GUARANTEES".  TO THE EXTENT THAT SUCH CONSUMER 
//      GUARANTEES CONTINUE TO APPLY, THEN TO THE FULL EXTENT PERMITTED BY THE APPLICABLE LEGISLATION, THE LIABILITY OF 
//      AUDINATE UNDER THE RELEVANT CONSUMER GUARANTEE IS LIMITED (WHERE PERMITTED AT AUDINATE’S OPTION) TO ONE OF 
//      FOLLOWING REMEDIES OR SUBSTANTIALLY EQUIVALENT REMEDIES:
//      4.1.    THE REPLACEMENT OF THE SOFTWARE, THE SUPPLY OF EQUIVALENT SOFTWARE, OR SUPPLYING RELEVANT SERVICES AGAIN;
//      4.2.    THE REPAIR OF THE SOFTWARE;
//      4.3.    THE PAYMENT OF THE COST OF REPLACING THE SOFTWARE, OF ACQUIRING EQUIVALENT SOFTWARE, HAVING THE RELEVANT 
//              SERVICES SUPPLIED AGAIN, OR HAVING THE SOFTWARE REPAIRED.
//
// 5.   This License does not grant any permissions or rights to use the trade marks (whether registered or unregistered), 
//      the trade names, or product names of Audinate. 
//
// 6.   If you choose to redistribute or sell the Software you may elect to offer support, maintenance, warranties, 
//      indemnities or other liability obligations or rights consistent with this License. However, you may only act on 
//      your own behalf and must not bind Audinate. You agree to indemnify and hold harmless Audinate, and its affiliates 
//      form any liability claimed or incurred by reason of your offering or accepting any additional warranty or additional 
//      liability. 
//
// chrono.cpp
//

#ifdef __linux__
#include <time.h>
#endif
#ifdef ARDUINO
#include <esp32-hal.h>
#endif
#ifdef _WIN32
#include <Windows.h>
#include <profileapi.h>
#endif

#include "chrono.h"
#include <assert.h>
#include <cwchar>
#include <math.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

namespace Audinate { namespace chrono {

typedef int64_t ChronoTime;         // Time is 64 bit nanoseconds - which is about 300 years

chrono_clock Chrono::clock = MONO;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PLATFORM DEPENDENT TIMER
//
// Get counter must be monotonic and constant frequency.  Code is provided here with a variable that is ideally
// static const and a function to compare that with at run time in debug mode as a check.
// The time must have an integral number of ns per tick - so NS_PER_SECOND/chronoFreq must be an integer.
//
#if defined(__linux__) || defined(__APPLE__)
inline ChronoTime chronoGetCounter(void)
{
    timespec now;
    clock_gettime(Chrono::getClock(), &now);
    return (ChronoTime)now.tv_sec * 1000000000 + now.tv_nsec;
};

#endif
#ifdef ARDUINO
static hw_timer_t *chronoTimer;
inline ChronoTime  chrono_get_counter(void)
{
    if (chronoTimer == 0)
        chronoTimer = timerBegin(1, 8, true);
    return timerRead(chronoTimer);
};
#endif
#ifdef _WIN32
inline ChronoTime chronoGetCounter(void)
{
    ChronoTime now*100;
    QueryPerformanceCounter((LARGE_INTEGER *)&now);
    return now;
};
#endif

inline timespec chronoNativeTimespec(ChronoTime t)
{
    timespec ret;
    ret.tv_sec  = t / 1000000000;
    ret.tv_nsec = t % 1000000000;
    return ret;
};

static const int32_t chronoNativeLog2Table[] = { // 256 entries 0x00 -> 0x80 or 8 bit effective
    0x00000000, 0x0001709c, 0x0002dfca, 0x00044d8c, 0x0005b9e6, 0x000724d9, 0x00088e69, 0x0009f698, 0x000b5d6a, 0x000cc2e0, 0x000e26fd, 0x000f89c5, 0x0010eb39, 0x00124b5b, 0x0013aa30, 0x001507b8,
    0x001663f7, 0x0017beef, 0x001918a1, 0x001a7112, 0x001bc842, 0x001d1e35, 0x001e72ec, 0x001fc66a, 0x002118b1, 0x002269c3, 0x0023b9a3, 0x00250853, 0x002655d4, 0x0027a229, 0x0028ed54, 0x002a3757,
    0x002b8034, 0x002cc7ee, 0x002e0e86, 0x002f53fe, 0x00309858, 0x0031db96, 0x00331dba, 0x00345ec6, 0x00359ebc, 0x0036dd9e, 0x00381b6e, 0x0039582c, 0x003a93dd, 0x003bce80, 0x003d0818, 0x003e40a6,
    0x003f782d, 0x0040aeaf, 0x0041e42b, 0x004318a6, 0x00444c1f, 0x00457e9a, 0x0046b017, 0x0047e098, 0x0049101f, 0x004a3ead, 0x004b6c44, 0x004c98e6, 0x004dc493, 0x004eef4f, 0x00501919, 0x005141f4,
    0x005269e1, 0x005390e2, 0x0054b6f8, 0x0055dc24, 0x00570069, 0x005823c7, 0x00594640, 0x005a67d5, 0x005b8887, 0x005ca859, 0x005dc74b, 0x005ee55f, 0x00600296, 0x00611ef1, 0x00623a72, 0x0063551a,
    0x00646eea, 0x006587e4, 0x0066a009, 0x0067b75a, 0x0068cdd8, 0x0069e385, 0x006af862, 0x006c0c70, 0x006d1fb0, 0x006e3223, 0x006f43cc, 0x007054aa, 0x007164bf, 0x0072740c, 0x00738292, 0x00749053,
    0x00759d50, 0x0076a989, 0x0077b4ff, 0x0078bfb5, 0x0079c9ab, 0x007ad2e1, 0x007bdb5a, 0x007ce316, 0x007dea16, 0x007ef05b, 0x007ff5e6, 0x0080fab9, 0x0081fed4, 0x00830239, 0x008404e8, 0x008506e2,
    0x00860828, 0x008708bc, 0x0088089e, 0x008907cf, 0x008a0650, 0x008b0422, 0x008c0146, 0x008cfdbe, 0x008df989, 0x008ef4a9, 0x008fef1f, 0x0090e8eb, 0x0091e20f, 0x0092da8b, 0x0093d260, 0x0094c990,
    0x0095c01a, 0x0096b601, 0x0097ab44, 0x00989fe4, 0x009993e3, 0x009a8742, 0x009b7a00, 0x009c6c1f, 0x009d5da0, 0x009e4e83, 0x009f3eca, 0x00a02e74, 0x00a11d84, 0x00a20bf9, 0x00a2f9d5, 0x00a3e718,
    0x00a4d3c2, 0x00a5bfd6, 0x00a6ab53, 0x00a7963a, 0x00a8808c, 0x00a96a4a, 0x00aa5374, 0x00ab3c0c, 0x00ac2411, 0x00ad0b85, 0x00adf268, 0x00aed8bc, 0x00afbe80, 0x00b0a3b5, 0x00b1885c, 0x00b26c77,
    0x00b35004, 0x00b43306, 0x00b5157d, 0x00b5f769, 0x00b6d8cb, 0x00b7b9a4, 0x00b899f5, 0x00b979bd, 0x00ba58ff, 0x00bb37b9, 0x00bc15ee, 0x00bcf39d, 0x00bdd0c8, 0x00bead6e, 0x00bf8991, 0x00c06531,
    0x00c1404f, 0x00c21aeb, 0x00c2f506, 0x00c3cea0, 0x00c4a7ba, 0x00c58055, 0x00c65872, 0x00c73010, 0x00c80731, 0x00c8ddd4, 0x00c9b3fb, 0x00ca89a7, 0x00cb5ed7, 0x00cc338c, 0x00cd07c7, 0x00cddb88,
    0x00ceaed0, 0x00cf819f, 0x00d053f7, 0x00d125d7, 0x00d1f740, 0x00d2c832, 0x00d398af, 0x00d468b6, 0x00d53848, 0x00d60765, 0x00d6d60f, 0x00d7a446, 0x00d87209, 0x00d93f5a, 0x00da0c3a, 0x00dad8a8,
    0x00dba4a4, 0x00dc7031, 0x00dd3b4e, 0x00de05fb, 0x00ded039, 0x00df9a09, 0x00e0636a, 0x00e12c5e, 0x00e1f4e5, 0x00e2bcff, 0x00e384ad, 0x00e44bf0, 0x00e512c7, 0x00e5d933, 0x00e69f35, 0x00e764cd,
    0x00e829fb, 0x00e8eec1, 0x00e9b31e, 0x00ea7712, 0x00eb3a9f, 0x00ebfdc5, 0x00ecc083, 0x00ed82db, 0x00ee44cd, 0x00ef065a, 0x00efc781, 0x00f08843, 0x00f148a1, 0x00f2089b, 0x00f2c832, 0x00f38765,
    0x00f44636, 0x00f504a4, 0x00f5c2b0, 0x00f6805a, 0x00f73da4, 0x00f7fa8c, 0x00f8b714, 0x00f9733c, 0x00fa2f04, 0x00faea6d, 0x00fba578, 0x00fc6023, 0x00fd1a71, 0x00fdd460, 0x00fe8df2, 0x00ff4728,
    0x01000000};

typedef uint32_t        chronoNative8f24;
inline chronoNative8f24 chronoNativeLog2(uint64_t x) // Create a 8.24 float which is log2 of the input
{
    int y = 9; // We have 8 bits (257) table entries, and one extra for rounding - so need to shift 0x001 to 0x200 by 9
    if (x == 0)
        return 0; // Avoid this error case (optimize out as an assert if needed)
    while (x >= 0x00000400) {
        x = x >> 1;
        y++;
    }; // Scale it to be from 512 - 1024
    while (x < 0x00000200) {
        x = x << 1;
        y--;
    };                                                                    // Counting bits - can be done with roll & mask
    return (y << 24) + chronoNativeLog2Table[((x & 0x000001FF) + 1) / 2]; // Reduction of bias from the +1/2
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CHRONOMETER SPECIFIC CORE STRUCTURE - Abstracted and mostly platform independent
//
// General implementation may be optimized if needed, for example for fixed width or power of 2 bins.
//
// A note on concurrency.  Reset and Configure are not strictly thread safe.  However, we use stale
// pointer cycling and deliberate ordering of things to ensure the worker threads are crash safe.
//
// If needed, the events value can be used as a constancy test for bracketing.  The bin values are
// only ever incremented other than in a reset, and so the bin set is naturally consistent.
//

struct chrono_t // Struct for machine specific timing stamp
// 64 + 4 + 4 + 8 + 8 + 8 + 8 + 8 + 4 + 4 + 101*4 + 4
{
    char       name[64];  // Name of the counter
    HistFlag   flags;     // Options about how this setup - Log, Dither, Counter
    int32_t    configs;   // Increments each time we reconfig (reset) to let clients know bins have changed
    int64_t    events;    // Number of times event has happened since last reset
    ChronoTime startTime; // Time of the first add after a config, and therefore the time of event 0 (note this has arbitrary origin)
    ChronoTime lastTime;  // Last time an update happened, so this is time of event N=count
    ChronoTime lastDiff;  // Last time difference between calls (must fit in int) valid only if events>=2
    ChronoTime start;     // The left edge of the first bin - if width = 1 it is also the centre
    uint32_t   width;     // The width of each bin (no sense being fractional and must be >= 1)
    int32_t    bins;      // The number of bins also allocated size of data
    uint32_t   bin[101];  // Variable sized structure to hold the bins - note sum(bins) = count-1
    uint32_t   rand;      // A random number generator of some form (may be simple cycle)
};

Chrono::Chrono()
{
    assert(sizeof(mData) >= sizeof(chrono_t));               // Ensure hidden data allocation is sufficient

    chrono_t *p = (chrono_t *)mData;
    memset(p, 0, sizeof(chrono_t)); // Most initialize to zero
    p->width = 1;                   // code past config count = 0 creating a div0 exception
    strncpy(p->name, "CHRONO NOT CONFIGURED", sizeof(p->name) - 1);
    p->lastDiff = 0;
    p->lastTime = chronoGetCounter();
}

Chrono::~Chrono() {}

void Chrono::reset() // Reset without changing the config - use sparingly as each client must recalibrate
{
    chrono_t * p   = (chrono_t *)mData;
    ChronoTime now = chronoGetCounter();
    p->configs++;                                 // Only do this once - it also signals imminent data corruption
    chrono_t chrono;                              // Temporary chrono block to bit blit
    memcpy(&chrono, p, sizeof(chrono_t));         // Copy what was there
    memset(chrono.bin, 0, p->bins * sizeof(int)); // Clear the data
    chrono.events    = 0;                         // Reset event count
    chrono.startTime = now;                       // Set the time we reset, will be updated once events==1
    chrono.lastTime  = now;                       // Valid once events==1, not used until events==2
    chrono.lastDiff  = 0;                         // Valid only if events>=2
    chrono.rand      = p->width / 2;              // Reset the seed and centre it - be predictable in testing
    do {                                          // Loop to rinse and repeat if needed
        memcpy(p, &chrono, sizeof(chrono_t));     // Bit blit the new config
    } while (p->events != 0);                     // This not being zero indicates we were interrupted by an update
}

bool Chrono::config(float bin0, float binN, int bins, HistFlag flags, const char *name)
{
    chrono_t *p = (chrono_t *)mData;
    assert(bins > 1);
    assert(binN > bin0);

    if (p->configs > 0 && (p->flags & COUNTER))
        flags = (HistFlag)(flags | COUNTER);
    if (p->configs == 0 && name == nullptr)
        p->name[0] = 0;
    if (p->configs > 0 && name == nullptr)
        name = p->name;

    if (bins > (sizeof(p->bin) / sizeof(uint32_t)))
        bins = (sizeof(p->bin) / sizeof(uint32_t));

    ChronoTime freq = 1000000000;
    if (flags & HistFlag::COUNTER) freq = 1; // Hijack for counter

    if (flags & HistFlag::LOGX) // Log mode
    {
        if (bin0 * freq >= 1)
            p->start = chronoNativeLog2((uint64_t)(bin0 * freq));
        else
            p->start = chronoNativeLog2(1);
        p->width = (uint32_t)(chronoNativeLog2((uint64_t)(binN * freq)) - p->start) / (bins - 1);
    } else {
        p->width = (uint32_t)((binN - bin0) / (bins - 1) * freq); // This is likely the most coarse to quantize
        p->start = (ChronoTime)(bin0 * freq);                     //
    }
    if (p->width <= 0)
        p->width = 1; // Has to be at least one - counter resolution limit
    p->events = 0;    // This can signal a reconfigure underway or chrono premature
    p->bins   = bins;
    p->flags  = flags;
    if (name != nullptr)
        strncpy(p->name, name, sizeof(p->name) - 1);
    reset();
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MAIN EVENT UPDATERS
//
// Two variants are provided.  The first is the leanest and only allows for unitary event counts.
// The second allows the elapsed time to be registered against a number of events >=1.  This is useful when
// tracking, for example, the effective sample time when a variable number of samples may be received in
// a block.  The representation and all aspects of this remain the same, the update simply uses a divide
// through of the elapsed time by the number of events.
//

void Chrono::restart() { ((chrono_t *)mData)->lastTime = chronoGetCounter(); }

void Chrono::event(uint64_t now, int count)
{
    if (now == 0) now = chronoGetCounter();
    chrono_t *p = (chrono_t *)mData;
    if (p->events > 0) // First call is an edge case.  Number of logs of interval (sum(bins))
    {                  // equal to one les than the number of times update is called (count-1)
        p->lastDiff  = now - p->lastTime;
        ChronoTime t = p->lastDiff;
        if (count > 1) {
            t += (rand() % count);             // Dither this as we need to integer divide next
            t /= count;                        // This is an integer divide
        }
        if (p->flags & HistFlag::LOGX)
            t = chronoNativeLog2(t);
        t += rand() % p->width;                     // Dither for stochastic resonance - may optimize to nothing if rand next is always 0
        int bin = (int)((t - p->start) / p->width); // Could be done as a magic# mult
        if (bin >= p->bins)
            bin = p->bins - 1; // Could be a mask if optimzation needed
        if (bin < 0)
            bin = 0;
        p->bin[bin] += count;
    } else
        p->startTime = now;
    p->lastTime = now;
    p->events++;
}

void Chrono::count(int val, int count)
{
    ChronoTime now = chronoGetCounter();
    chrono_t * p   = (chrono_t *)mData;
    if (p->events == 0)
        p->startTime = now;
    if (p->flags & HistFlag::LOGX)
        val = chronoNativeLog2(val);
    val += (rand() % p->width);                   // Dither the bin
    int bin = (int)((val - p->start) / p->width); // Could be done as a magic# mult
    if (bin >= p->bins)
        bin = p->bins - 1;
    if (bin < 0)
        bin = 0;
    p->bin[bin] += count;
    p->lastTime = now;
    p->events += count;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// METHODS FOR ACCESSING DATA
//
//

int32_t  Chrono::configCount() { return ((chrono_t *)mData)->configs; }
int64_t  Chrono::eventCount() { return ((chrono_t *)mData)->events; }
timespec Chrono::now() { return chronoNativeTimespec(chronoGetCounter()); }
uint64_t Chrono::nowNs() { return chronoGetCounter(); }
timespec Chrono::startTime() { return chronoNativeTimespec(((chrono_t *)mData)->startTime); }
timespec Chrono::lastTime() { return chronoNativeTimespec(((chrono_t *)mData)->lastTime); }
int64_t  Chrono::diffNs() { return  ((chrono_t *)mData)->lastDiff; }
int64_t  Chrono::sinceNs() { return chronoGetCounter() - ((chrono_t *)mData)->lastTime; }
int64_t  Chrono::periodNs()
{
    chrono_t *p = (chrono_t *)mData;
    if (p->events <= 1)
        return 0;
    return (p->lastTime - p->startTime) / (p->events - 1);
}

inline uint32_t Chrono::rand() { ((chrono_t *)mData)->rand =  ((chrono_t *)mData)->rand * 0x0019660d + 0x3c6ef35f; return ((chrono_t *)mData)->rand; } // Classic rand PRNG


////////////////////////////////////////////////////////////////////////////////////////////////////////////
// USE AUD_HIST TO DO ALL OTHER STUFF WE MAY WANT WITH HISTOGRAM
//
// This will take a synchronous snapshot (option to be synchronous) of the bins, and also populate
// the other fields of a hist structure based on either accurate values, or in the case of sumX2
// and min it will derive approximate from the bins.
//
// Note that if this is called with the default h=NULL it will create a hist_t and that needs to be
// destroyed with a call to histDestroy.
//
// If there is a particular concern for consistency and you can afford to wait for the next event,
// call this with sync true - note it could block for up to 100ms seconds in a spin loop if there
// are no more events in that time.
//

void Chrono::histogram(Histogram *h)
{
    assert(h != nullptr);
    chrono_t * p    = (chrono_t *)mData;
    ChronoTime freq = 1000000000;
    if (p->flags & HistFlag::COUNTER) freq = 1;

    unsigned int AnInt = 0xFFFFFFE;                       // Be sure to use full precision sub and timespec and avoid overflow
    assert((unsigned int)*((HistType *)&AnInt) == AnInt); // Just to check hist_t is an int other wise we need to copy and cast bins
    float bin0, binN;

    if (p->flags & HistFlag::LOGX) {
        bin0 = powf(2.0F, (float)p->start / 16777216.0F) / freq;
        binN = powf(2.0F, ((float)p->start + (float)(p->bins - 1) * p->width) / 16777216.0F) / freq;
    } else {
        bin0 = (float)p->start / freq;
        binN = bin0 + (float)(p->bins - 1) * p->width / freq;
    }

    h->reconfig(bin0, binN, p->bins, p->flags | HistFlag::DITHER, p->bin, p->name);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Versions


}} // namespace Audinate::chrono

//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//