//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//
//
// 1.   Subject to the terms and conditions of this Licence, Audinate hereby grants you a worldwide, non-exclusive, 
//      no-charge, royalty free licence to copy, modify, merge, publish, redistribute, sublicense, and/or sell the 
//      Software, provided always that the following conditions are met: 
//      1.1.    the Software must accompany, or be incorporated in a licensed Audinate product, solution or offering 
//              or be used in a product, solution or offering which requires the use of another licensed Audinate 
//              product, solution or offering. The Software is not for use as a standalone product without any 
//              reference to Audinate’s products;
//      1.2.    the Software is provided as part of example code and as guidance material only without any warranty 
//              or expectation of performance, compatibility, support, updates or security; and
//      1.3.    the above copyright notice and this License must be included in all copies or substantial portions 
//              of the Software, and all derivative works of the Software, unless the copies or derivative works are 
//              solely in the form of machine-executable object code generated by the source language processor.
//
// 2.   TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
//      XPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
//      PURPOSE AND NONINFRINGEMENT. 
//
// 3.   TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL AUDINATE BE LIABLE ON ANY LEGAL THEORY 
//      (INCLUDING, WITHOUT LIMITATION, IN AN ACTION FOR BREACH OF CONTRACT, NEGLIGENCE OR OTHERWISE) FOR ANY CLAIM, 
//      LOSS, DAMAGES OR OTHER LIABILITY HOWSOEVER INCURRED.  WITHOUT LIMITING THE SCOPE OF THE PREVIOUS SENTENCE THE 
//      EXCLUSION OF LIABILITY SHALL INCLUDE: LOSS OF PRODUCTION OR OPERATION TIME, LOSS, DAMAGE OR CORRUPTION OF 
//      DATA OR RECORDS; OR LOSS OF ANTICIPATED SAVINGS, OPPORTUNITY, REVENUE, PROFIT OR GOODWILL, OR OTHER ECONOMIC 
//      LOSS; OR ANY SPECIAL, INCIDENTAL, INDIRECT, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES, ARISING OUT OF OR 
//      IN CONNECTION WITH THIS AGREEMENT, ACCESS OF THE SOFTWARE OR ANY OTHER DEALINGS WITH THE SOFTWARE, EVEN IF 
//      AUDINATE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH CLAIM, LOSS, DAMAGES OR OTHER LIABILITY.
//
// 4.   APPLICABLE LEGISLATION SUCH AS THE AUSTRALIAN CONSUMER LAW MAY APPLY REPRESENTATIONS, WARRANTIES, OR CONDITIONS, 
//      OR IMPOSES OBLIGATIONS OR LIABILITY ON AUDINATE THAT CANNOT BE EXCLUDED, RESTRICTED OR MODIFIED TO THE FULL 
//      EXTENT SET OUT IN THE EXPRESS TERMS OF THIS CLAUSE ABOVE "CONSUMER GUARANTEES".  TO THE EXTENT THAT SUCH CONSUMER 
//      GUARANTEES CONTINUE TO APPLY, THEN TO THE FULL EXTENT PERMITTED BY THE APPLICABLE LEGISLATION, THE LIABILITY OF 
//      AUDINATE UNDER THE RELEVANT CONSUMER GUARANTEE IS LIMITED (WHERE PERMITTED AT AUDINATE’S OPTION) TO ONE OF 
//      FOLLOWING REMEDIES OR SUBSTANTIALLY EQUIVALENT REMEDIES:
//      4.1.    THE REPLACEMENT OF THE SOFTWARE, THE SUPPLY OF EQUIVALENT SOFTWARE, OR SUPPLYING RELEVANT SERVICES AGAIN;
//      4.2.    THE REPAIR OF THE SOFTWARE;
//      4.3.    THE PAYMENT OF THE COST OF REPLACING THE SOFTWARE, OF ACQUIRING EQUIVALENT SOFTWARE, HAVING THE RELEVANT 
//              SERVICES SUPPLIED AGAIN, OR HAVING THE SOFTWARE REPAIRED.
//
// 5.   This License does not grant any permissions or rights to use the trade marks (whether registered or unregistered), 
//      the trade names, or product names of Audinate. 
//
// 6.   If you choose to redistribute or sell the Software you may elect to offer support, maintenance, warranties, 
//      indemnities or other liability obligations or rights consistent with this License. However, you may only act on 
//      your own behalf and must not bind Audinate. You agree to indemnify and hold harmless Audinate, and its affiliates 
//      form any liability claimed or incurred by reason of your offering or accepting any additional warranty or additional 
//      liability. 
//
// hist.cpp
//

#ifdef __linux__
#else
#ifdef ARDUINO
#else
#ifdef WIN32
#include <Windows.h>
#include <profileapi.h>
#endif
#endif
#endif

#include "hist.h"
#include "versions.h"
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

namespace Audinate { namespace hist {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// STATS SPECIFIC CORE STRUCTURE - Mostly platform independent
//
// A note on concurrency.  Reset and Configure are not strictly thread safe.  However, we use stale
// pointer cycling and deliberate ordering of things and double writes to minimize the potential for
// error and any inconsistency (whilst extremely rare) will almost surely happen in the consumer calls
// not in the running profiled thread.  The only requirement being that Configure is not called instantly in
// succession with increasing bin sizes.  That would just be silly.
//

typedef struct hist_t // Structure of the first 5 fields is used elsewhere (aud_interval) do not change
{
    char     name[64]; // Name of the histogram
    int32_t  configs;  // Increments each time we reconfig (or reset) to let clients know bins have changed
    HistFlag flags;    // For things like dither being enabled
    float    bin0;     // The centre of the first bin
    float    width;    // The width of each bin
    int32_t  count;    // The number of times add has been called
    int32_t  bins;     // The number of bins
    HistType bin[101]; // The bin data
    uint32_t rand;     // Linear congruent generated random number for stochastic resonance
    HistType N;        // Sum of weight of adds - usually an integer but may not be equal to count unless adds are all n=1
    float    sumX;     // Actual sum of random variable - not biased by bin range
    float    sumX2;    // Actual sum of square of random variable - not biased by bin range but precision limited
    float    min;      // Actual min value
    float    max;      // Actual max value
} Hist;

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SIMPLE ACCESS
//

HistFlag Histogram::flags() const { return ((hist_t *)mData)->flags; }

float histMeanLin(const hist_t *p)
{
    if (p != nullptr && p->N > 0)
        return p->sumX / p->N;
    return 0.0F;
}

float histStdLin(const hist_t *p)
{
    if (p != nullptr && p->N > 1)
        return sqrtf(fabsf((p->sumX2 - p->sumX * p->sumX / p->N) / (p->N - 1)));
    return 0.0F;
}
float histMaxLin(const hist_t *p)
{
    if (p != nullptr)
        return p->max;
    return 0.0F;
}
float histMinLin(const hist_t *p)
{
    if (p != nullptr)
        return p->min;
    return 0.0F;
}
float histBincentLin(const hist_t *p, int bin)
{
    if (p != nullptr && bin >= 0)
        return p->bin0 + bin * p->width;
    return 0.0F;
}
float histBinWidthLin(const hist_t *p)
{
    if (p != nullptr)
        return p->width;
    return 1.0F;
} // Defensive for divide edge case

int      Histogram::bins() const { return ((hist_t *)mData)->bins; }
HistType Histogram::bin(int bin) const
{
    if (bin < 0 || bin >= bins())
        return 0;
    return ((hist_t *)mData)->bin[bin];
}

inline uint32_t histRandNext(int x) { return x * 0x0019660d + 0x3c6ef35f; }; // Long term unbiased, but slower to converge and costs an extra multiply - From Numerical Recipes

Histogram::Histogram()
{
    assert(sizeof(mData) >= sizeof(hist_t));
    hist_t *p = (hist_t *)mData;
    memset(p, 0, sizeof(hist_t)); // Most initialize to zero
    p->width = 1.0F;              // code past config count = 0 to avoud /0
    strncpy(p->name, "HIST NOT CONFIGURED", sizeof(p->name) - 1);
}

Histogram::~Histogram() {}

void Histogram::reset() // Reset without changing the config - use sparingly as each client must recalibrate
{
    hist_t *p = (hist_t *)mData;
    p->configs++;               // Only do this once
    for (int n = 0; n < 2; n++) // Clear all of the relevant fields, rinse and repeat
    {                           // just in case an update occurred part way through
        p->count = 0;
        p->N     = 0;
        p->sumX  = 0;
        p->sumX2 = 0;
        p->min   = 0;
        p->max   = 0;
        p->rand  = (int)(0.5F / 4294967296.0F);
        memset(p->bin, 0, p->bins * sizeof(HistType));
    }
}

bool Histogram::config(float bin0, float binN, int bins, HistFlag flags, const char *name)
{
    hist_t *p = (hist_t *)mData;
    if (bins <= 2)
        return false;
    if (binN <= bin0)
        return false;

    if (bins > (sizeof(p->bin) / sizeof(HistType)))
        bins = (sizeof(p->bin) / sizeof(HistType));

    if ((flags & LOGX) != false && bin0 == 0.0F)
        return false;

    p->flags = flags;
    if (flags & LOGX) {
        p->bin0  = logf(bin0);
        p->width = (logf(binN) - logf(bin0)) / (bins - 1);
    } else {
        p->bin0  = bin0;
        p->width = (binN - bin0) / (bins - 1);
    };
    p->bins = bins;
    if (name == nullptr)
        p->name[0] = 0;
    else
        strncpy(p->name, name, sizeof(p->name) - 1);
    reset();
    return true;
}

void Histogram::add(float x, HistType n)
{
    hist_t *p = (hist_t *)mData;
    if (p->configs == 0)
        return;
    int bin;
    if ((p->flags & LOGX) && x > 0.0F)
        x = logf(x);
    if (p->flags & DITHER) {             // Adding a dither
        p->rand = histRandNext(p->rand); // Update random generator
        bin     = (int)((x - p->bin0) / p->width + (float)p->rand * (1.0F / 4294967296.0F));
    } else
        bin = (int)((x - p->bin0) / p->width + 0.5F); // Simple bin calculation - add 0.5 so no bias

    if (bin < 0)
        bin = 0;
    if (bin >= p->bins)
        bin = p->bins - 1;
    p->bin[bin] += n; // Atomic change to the histogram
    p->N += n;
    p->sumX += x;
    p->sumX2 += x * x;
    if (p->count == 0 || x > p->max)
        p->max = x; // Note the edge case of time 0 for max if x's are negative
    if (p->count == 0 || x < p->min)
        p->min = x; // Edge case for min if future xs are positive
    p->count++;
    return;
}

bool Histogram::reconfig(float bin0, float binN, int bins, HistFlag flags, uint32_t *bin, const char *name)
{
    config(bin0, binN, bins, flags);
    hist_t *p = (hist_t *)mData;
    memcpy(p->bin, bin, p->bins * sizeof(HistType));
    for (int n = 0; n < bins; n++)
        p->N += bin[n];
    for (int n = 0; n < bins; n++)
        p->sumX += bin[n] * (p->bin0 + n * p->width);
    for (int n = 0; n < bins; n++)
        p->sumX2 += bin[n] * (p->bin0 + n * p->width) * (p->bin0 + n * p->width);
    int n;
    for (n = 0; n < bins && bin[n] == 0; n++)
        ;
    if (n < bins)
        p->min = p->bin0 + n * p->width;
    for (n = bins - 1; n > 0 && bin[n] == 0; n--)
        ;
    if (n >= 0)
        p->max = p->bin0 + n * p->width;
    p->count = (int)p->N;
    if (name == nullptr)
        p->name[0] = 0;
    else
        strncpy(p->name, name, sizeof(p->name) - 1);
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SOME USEFUL FUNCTIONS THAT OPERATE ON A STATS BLOCK
//
//

HistType histN(const hist_t *p, bool cull)
{
    if (p == NULL || p->bins == 0 || p->bin == NULL)
        return 0;
    if (cull == false)
        return p->N;
    HistType N = 0;
    for (int n = 1; n < p->bins - 1; n++)
        N += p->bin[n];
    return N;
}

HistType Histogram::n(bool cull) const { return histN((hist_t *)mData, cull); }

float histSum(const hist_t *p, bool cull)
{
    if (p == NULL || p->bins == 0 || p->bin == NULL)
        return 0;
    if (cull == false)
        return p->sumX;
    float S = 0;
    for (int n = 1; n < p->bins - 1; n++)
        S += p->bin[n] * (p->bin0 + p->width * n);
    return S;
}

float Histogram::sum(bool cull) const { return histSum((hist_t *)mData, cull); }

HistType histPeak(const hist_t *p, bool cull = false)
{
    if (p == NULL || p->bins <= 0 || p->bin == NULL)
        return 0;
    HistType peak = p->bin[0];
    for (int n = 0 + (cull == true); n < p->bins - (cull == true); n++)
        if (p->bin[n] > peak)
            peak = p->bin[n];
    return peak;
}

HistType Histogram::peak(bool cull) const { return histPeak((hist_t *)mData, cull); }

float histBinMaxLin(const hist_t *p)
{
    if (p == nullptr || p->bins <= 0 || p->bin == NULL)
        return 0.0F;
    int bin = p->bins - 1;
    while (bin >= 0 && p->bin[bin] == (HistType)0)
        bin--;
    if (bin < 0)
        return p->bin0 + p->width * p->bins / 2.0F; // If no data - a bit arbitrary
    else
        return p->bin0 + p->width * (bin + 0.5F); // We cant be sure it wasn't up to the right edge
}

float histBinMinLin(const hist_t *p)
{
    assert(p != nullptr && p->bins > 0 && p->bin != nullptr);
    int bin = 0;
    while (bin < p->bins && p->bin[bin] == (HistType)0)
        bin++;
    if (bin < 0)
        return p->bin0 + p->width * p->bins / 2; // If no data - a bit arbitrary
    else
        return p->bin0 + p->width * (bin - 0.5F); // We cant be sure it wasn't as low as the left edge
}

float histMomentLin(const hist_t *p, int order, bool cull)
{
    assert(p != nullptr && p->bins > 0 && p->bin != nullptr);
    float sumn  = 0.0F;
    float sumxo = 0.0F;
    float x     = p->bin0 + p->width * (cull == true);
    for (int b = 0 + (cull == true); b < p->bins - (cull == true); b++) {
        sumn += p->bin[b];
        sumxo += p->bin[b] * powf(x, (float)order);
        x += p->width;
    }
    if (sumn >= 0)
        return sumxo / sumn;
    else
        return 0.0F;
}

float histBinMeanLin(const hist_t *p, bool cull) { return histMomentLin(p, 1, cull); };
float histBinStdLin(const hist_t *p, bool cull)
{
    float ux  = histMomentLin(p, 1, cull);
    float ux2 = histMomentLin(p, 2, cull);
    return sqrtf(ux2 - ux * ux);
}

float histPercentLin(const hist_t *p, float percent, bool cull)
{
    assert(p != nullptr && p->bins > 0 && p->bin != nullptr);
    float sumn = 0.0F;
    int   b;
    for (b = 0 + (cull == true); b < p->bins - (cull == true); b++)
        sumn += p->bin[b];
    if (sumn == 0.0F)
        return p->bin0 + p->width * p->bins / 2;

    float cut = percent / 100.0F * sumn;
    sumn      = 0.0F;
    for (b = 0 + (cull == true); b < p->bins - (cull == true) && sumn < cut; b++)
        sumn += p->bin[b];

    if (p->bin[b - 1] > (HistType)0)
        return p->bin0 + (b - 0.5F - (sumn - cut) / p->bin[b - 1]) * p->width;
    else
        return p->bin0 + (b - 0.5F) * p->width;
}

float histMedianLin(const hist_t *p, bool cull) { return histPercentLin(p, 50.0F, cull); };

float histModeLin(const hist_t *p, bool cull)
{
    if (p == NULL || p->bins <= 0 || p->bin == NULL)
        return 0;
    HistType peak = p->bin[0];
    int      at   = 0;
    for (int n = 0 + (cull == true); n < p->bins - (cull == true); n++)
        if (p->bin[n] > peak) {
            peak = p->bin[n];
            at   = n;
        };

    // TODO - do the spline and max finding here

    return p->bin0 + at * p->width;
}

float histBinMax(const hist_t *p)
{
    if (p->flags & LOGX)
        return expf(histBinMaxLin(p));
    else
        return histBinMaxLin(p);
}

float histBinMin(const hist_t *p)
{
    if (p->flags & LOGX)
        return expf(histBinMinLin(p));
    else
        return histBinMinLin(p);
}
// float aud_hist_moment (const hist_t* p, int o, bool c)	{ if (p->flags&LOGX) return expf(aud_hist_moment_lin(p,o,c)); else return histMomentLin(p,o,c); }
float histBinMean(const hist_t *p, bool c)
{
    if (p->flags & LOGX)
        return expf(histBinMeanLin(p, c));
    else
        return histBinMeanLin(p, c);
}

float Histogram::binMean(bool cull) const { return histBinMean((hist_t *)mData, cull); }

float histBinStd(const hist_t *p, bool c)
{
    if (p->flags & LOGX)
        return expf(histBinStdLin(p, c));
    else
        return histBinStdLin(p, c);
}

float Histogram::binStd(bool cull) const { return histBinStd((hist_t *)mData, cull); }

float histPercent(const hist_t *p, float f, bool c)
{
    if (p->flags & LOGX)
        return expf(histPercentLin(p, f, c));
    else
        return histPercentLin(p, f, c);
}

float Histogram::percent(float percent, bool cull) const { return histPercent((hist_t *)mData, percent, cull); }

float histMedian(const hist_t *p, bool c)
{
    if (p->flags & LOGX)
        return expf(histMedianLin(p, c));
    else
        return histMedianLin(p, c);
}

float Histogram::median(bool cull) const { return histMedian((hist_t *)mData, cull); }

float histMode(const hist_t *p, bool c)
{
    if (p->flags & LOGX)
        return expf(histModeLin(p, c));
    else
        return histModeLin(p, c);
}

float Histogram::mode(bool cull) const { return histMode((hist_t *)mData, cull); }

float histMean(const hist_t *p)
{
    if (p->flags & LOGX)
        return expf(histMeanLin(p));
    else
        return histMeanLin(p);
}

float Histogram::mean() const { return histMean((hist_t *)mData); }

float histStd(const hist_t *p)
{
    if (p->flags & LOGX)
        return expf(histStdLin(p)) * histMean(p);
    else
        return histStdLin(p);
}

float Histogram::std() const { return histStd((hist_t *)mData); }

float histMax(const hist_t *p)
{
    if (p->flags & LOGX)
        return expf(histMaxLin(p));
    else
        return histMaxLin(p);
}

float Histogram::max() const { return histMax((hist_t *)mData); }

float histMin(const hist_t *p)
{
    if (p->flags & LOGX)
        return expf(histMinLin(p));
    else
        return histMinLin(p);
}

float Histogram::min() const { return histMin((hist_t *)mData); }

float histBinCenter(const hist_t *p, int n)
{
    if (p->flags & LOGX)
        return expf(histBincentLin(p, n));
    else
        return histBincentLin(p, n);
}

float Histogram::binCenter(int bin) const { return histBinCenter((hist_t *)mData, bin); }

float histBinWidth(const hist_t *p)
{
    if (p->flags & LOGX)
        return expf(histBinWidthLin(p));
    else
        return histBinWidthLin(p);
}

float Histogram::binWidth() const { return histBinWidth((hist_t *)mData); }

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ASCII PLOT
//
//

#define pos(x, y) ((y)*width + (x))
const char symbolsAscii[] = {(char)5, ' ', '_', '.', 'x', 'X'}; //   _.xX

#ifndef min
#define min(a, b) (((a) < (b)) ? (a) : (b))
#define max(a, b) (((a) > (b)) ? (a) : (b))
#endif

#define symbol(symbols, x) (symbols[max(0, min(symbols[0] - 1, (int)((x)*symbols[0] + 0.5))) + 1])

bool histText(const hist_t *p, int barHeight, char *str, HistTextOption flags, int yMax, const char *symbols)
{
    if (p == nullptr || p->bins == 0 || p->bin == nullptr)
        return false;

    if (p->bins <= 2 || p->configs == 0 || p->width == 0) {
        strncpy(str, "BAD HISTOGRAM", 15);
        return false;
    };

    if (yMax == 0)
        yMax = histPeak(p);
    if (yMax == 0)
        yMax = 1;

    if (symbols == 0)
        symbols = symbolsAscii;

    bool ylabel     = flags & Y_LABEL;
    bool xlabel     = flags & X_LABEL;
    int  width      = p->bins + 2 + 2 * ylabel;
    int  fullHeight = barHeight + 2 * xlabel + (((flags & PERCENT) | (flags & CUM_PER)) > 1) * 3;

    memset(str, ' ', (width * fullHeight));
    str[(width * fullHeight)] = 0;

    for (int n = 0; n < fullHeight; n++) {
        str[pos(width - 2, n)] = '\r';
        str[pos(width - 1, n)] = '\n';
    };

    float Ra = (barHeight - 0.2001F) / logf((yMax + 1) / 2.0F);
    float Rb = 0.2001F - Ra * logf(2.0F);

    for (int h = 0; h < barHeight; h++)
        for (int b = 0; b < p->bins; b++) {
            if (!(flags & LOGY))
                str[pos(b + 2 * ylabel, h)] = symbol(symbols, (float)p->bin[b] / yMax * barHeight - barHeight + 1 + h);
            else
                str[pos(b + 2 * ylabel, h)] = symbol(symbols, Ra * logf((float)p->bin[b] + 1) + Rb - barHeight + 1 + h);
        }

    if (ylabel && barHeight >= 8 && barHeight < 90) {
        char ylab[100];
        snprintf(ylab, 100, "%-10.4g%80s", (float)yMax, "");
        if (!(flags & LOGY))
            ylab[barHeight - 1] = '0';
        else
            ylab[barHeight - 1] = '1';
        for (int h = 0; h < barHeight; h++) {
            str[pos(0, h)] = ylab[h];
            str[pos(1, h)] = '|';
        };
    }

    if (xlabel && p->bins > 26 && p->bins < 1023) {
        char xlab[1024];
        snprintf(xlab, 1024, "%-8.2G%*s%8.2G%*s%8.2G", histBinCenter(p, 0), p->bins / 2 - 15, "", histBinCenter(p, (p->bins - 1) / 2), p->bins - 9 - (p->bins / 2), "", histBinCenter(p, p->bins - 1));
        for (int n = 0; n < p->bins; n++) {
            str[pos(n + 2 * ylabel, barHeight + 1)] = xlab[n];
            str[pos(n + 2 * ylabel, barHeight)]     = '-';
        };
    }

    if (p->name != nullptr || !(flags & NO_TITLE)) {
        char tmp[72];
        snprintf(tmp, sizeof(tmp) - 1, "[ %s ]", p->name);
        int len = (int)strlen(tmp);
        for (int n = 0; n < width - 15 && n < len; n++) {
            str[pos(n + 2 * ylabel + (p->bins - len) / 2, 1)] = tmp[n];
        };
    }

    if ((flags & STATS) && p->bins > 20 && barHeight > 8) {
        int   line = 1;
        bool  cull = flags & CULL;
        float x;
        char  tmp[20];

        if (flags & TOTAL) {
            unsigned int N = histN(p, cull);
            snprintf(tmp, 20, "|total %11d|", N);
            for (int n = 0; n < 19; n++) {
                str[pos(n + p->bins - 22 + 2 * ylabel, line)] = tmp[n];
            };
            line++;
        }

        if (flags & SUM) {
            float S = histSum(p, cull);
            snprintf(tmp, 20, "|sum   %11.3E|", S);
            for (int n = 0; n < 19; n++) {
                str[pos(n + p->bins - 22 + 2 * ylabel, line)] = tmp[n];
            };
            line++;
        }

        if (flags & MEAN) {
            if (!cull)
                x = histMean(p);
            else
                x = histBinMean(p, cull);
            snprintf(tmp, 20, "|mean  %11.3E|", x);
            for (int n = 0; n < 19; n++) {
                str[pos(n + p->bins - 22 + 2 * ylabel, line)] = tmp[n];
            };
            line++;
        }

        if (flags & STD) {
            if (!cull)
                x = histStd(p);
            else
                x = histBinStd(p, cull);
            snprintf(tmp, 20, "|std   %11.3E|", x);
            for (int n = 0; n < 19; n++) {
                str[pos(n + p->bins - 22 + 2 * ylabel, line)] = tmp[n];
            };
            line++;
        }

        if (flags & MEDIAN) {
            x = histMedian(p, cull);
            snprintf(tmp, 20, "|median%11.3E|", x);
            for (int n = 0; n < 19; n++) {
                str[pos(n + p->bins - 22 + 2 * ylabel, line)] = tmp[n];
            };
            line++;
        }

        if (flags & MODE) {
            x = histMode(p, cull);
            snprintf(tmp, 20, "|mode  %11.3E|", x);
            for (int n = 0; n < 19; n++) {
                str[pos(n + p->bins - 22 + 2 * ylabel, line)] = tmp[n];
            };
            line++;
        }

        if (flags & MIN) {
            x = histMin(p);
            snprintf(tmp, 20, "|min   %11.3E|", x);
            for (int n = 0; n < 19; n++) {
                str[pos(n + p->bins - 22 + 2 * ylabel, line)] = tmp[n];
            };
            line++;
        }

        if (flags & MAX) {
            x = histMax(p);
            snprintf(tmp, 20, "|max   %11.3E|", x);
            for (int n = 0; n < 19; n++) {
                str[pos(n + p->bins - 22 + 2 * ylabel, line)] = tmp[n];
            };
            line++;
        }
    }

    if ((flags & PERCENT) || (flags & CUM_PER)) {
        float *fBin = (float *)malloc(p->bins * sizeof(float));
        int    n;
        for (n = 0; n < p->bins; n++) {
            fBin[n] = (float)p->bin[n] / p->N;
        };
        if (flags & CUM_PER)
            for (int n = 1; n < p->bins; n++) {
                fBin[n] = fBin[n - 1] + fBin[n];
            }
        for (n = 0; n < p->bins; n++) {
            if (fBin[n] < 0)
                fBin[n] = 0;
            if (fBin[n] > 1)
                fBin[n] = 1;
        };

        for (n = 0; n < p->bins; n += 2) {
            char tmp[5];
            snprintf(tmp, 5, "%3.0f", fBin[n] * 100.0F);
            if (n > 2 && (fabs(fBin[n] - fBin[n - 1]) < 0.005F))
                continue;
            if (fBin[n] > 0.005 && (fBin[n] < 0.995F))
                for (int s = 0; s < 3; s++)
                    str[pos(n + 2 * ylabel, barHeight + 2 * xlabel + s)] = tmp[s];
        }
    }

    return true;
}

bool Histogram::text(int barHeight, char *str, HistTextOption flags, int yMax, const char *symbols) const { return histText((hist_t *)mData, barHeight, str, flags, yMax, symbols); }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Versions

const char * Histogram::versionFull() { return ATS_CORE_GIT_COMPONENT_TAG_VERSION_FULL; }
const char * Histogram::versionHash() { return ATS_CORE_GIT_HASH_SHORT; }
unsigned int Histogram::versionMajor() { return ATS_CORE_GIT_VERSION_MAJOR; }
unsigned int Histogram::versionMinor() { return ATS_CORE_GIT_VERSION_MINOR; }
unsigned int Histogram::versionPatch() { return ATS_CORE_GIT_VERSION_PATCH; }
const char * Histogram::versionSuffix() { return ATS_CORE_GIT_VERSION_SUFFIX; }

}} // namespace Audinate::hist

//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//