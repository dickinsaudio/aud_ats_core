//
// AUDIO TEMPORAL STRETCHER CODE LICENSE
//
// PERMISION NOTICE
//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//
//
// 1.   Subject to the terms and conditions of this Licence, Audinate hereby grants you a worldwide, non-exclusive, 
//      no-charge, royalty free licence to copy, modify, merge, publish, redistribute, sublicense, and/or sell the 
//      Software, provided always that the following conditions are met: 
//      1.1.    the Software must accompany, or be incorporated in a licensed Audinate product, solution or offering 
//              or be used in a product, solution or offering which requires the use of another licensed Audinate 
//              product, solution or offering. The Software is not for use as a standalone product without any 
//              reference to Audinate’s products;
//      1.2.    the Software is provided as part of example code and as guidance material only without any warranty 
//              or expectation of performance, compatibility, support, updates or security; and
//      1.3.    the above copyright notice and this License must be included in all copies or substantial portions 
//              of the Software, and all derivative works of the Software, unless the copies or derivative works are 
//              solely in the form of machine-executable object code generated by the source language processor.
//
// 2.   TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
//      XPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
//      PURPOSE AND NONINFRINGEMENT. 
//
// 3.   TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL AUDINATE BE LIABLE ON ANY LEGAL THEORY 
//      (INCLUDING, WITHOUT LIMITATION, IN AN ACTION FOR BREACH OF CONTRACT, NEGLIGENCE OR OTHERWISE) FOR ANY CLAIM, 
//      LOSS, DAMAGES OR OTHER LIABILITY HOWSOEVER INCURRED.  WITHOUT LIMITING THE SCOPE OF THE PREVIOUS SENTENCE THE 
//      EXCLUSION OF LIABILITY SHALL INCLUDE: LOSS OF PRODUCTION OR OPERATION TIME, LOSS, DAMAGE OR CORRUPTION OF 
//      DATA OR RECORDS; OR LOSS OF ANTICIPATED SAVINGS, OPPORTUNITY, REVENUE, PROFIT OR GOODWILL, OR OTHER ECONOMIC 
//      LOSS; OR ANY SPECIAL, INCIDENTAL, INDIRECT, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES, ARISING OUT OF OR 
//      IN CONNECTION WITH THIS AGREEMENT, ACCESS OF THE SOFTWARE OR ANY OTHER DEALINGS WITH THE SOFTWARE, EVEN IF 
//      AUDINATE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH CLAIM, LOSS, DAMAGES OR OTHER LIABILITY.
//
// 4.   APPLICABLE LEGISLATION SUCH AS THE AUSTRALIAN CONSUMER LAW MAY APPLY REPRESENTATIONS, WARRANTIES, OR CONDITIONS, 
//      OR IMPOSES OBLIGATIONS OR LIABILITY ON AUDINATE THAT CANNOT BE EXCLUDED, RESTRICTED OR MODIFIED TO THE FULL 
//      EXTENT SET OUT IN THE EXPRESS TERMS OF THIS CLAUSE ABOVE "CONSUMER GUARANTEES".  TO THE EXTENT THAT SUCH CONSUMER 
//      GUARANTEES CONTINUE TO APPLY, THEN TO THE FULL EXTENT PERMITTED BY THE APPLICABLE LEGISLATION, THE LIABILITY OF 
//      AUDINATE UNDER THE RELEVANT CONSUMER GUARANTEE IS LIMITED (WHERE PERMITTED AT AUDINATE’S OPTION) TO ONE OF 
//      FOLLOWING REMEDIES OR SUBSTANTIALLY EQUIVALENT REMEDIES:
//      4.1.    THE REPLACEMENT OF THE SOFTWARE, THE SUPPLY OF EQUIVALENT SOFTWARE, OR SUPPLYING RELEVANT SERVICES AGAIN;
//      4.2.    THE REPAIR OF THE SOFTWARE;
//      4.3.    THE PAYMENT OF THE COST OF REPLACING THE SOFTWARE, OF ACQUIRING EQUIVALENT SOFTWARE, HAVING THE RELEVANT 
//              SERVICES SUPPLIED AGAIN, OR HAVING THE SOFTWARE REPAIRED.
//
// 5.   This License does not grant any permissions or rights to use the trade marks (whether registered or unregistered), 
//      the trade names, or product names of Audinate. 
//
// 6.   If you choose to redistribute or sell the Software you may elect to offer support, maintenance, warranties, 
//      indemnities or other liability obligations or rights consistent with this License. However, you may only act on 
//      your own behalf and must not bind Audinate. You agree to indemnify and hold harmless Audinate, and its affiliates 
//      form any liability claimed or incurred by reason of your offering or accepting any additional warranty or additional 
//      liability. 
//
// ats.cpp
//

#include "ats.h"
#include "ats_t.h"
#include "versions.h"

#ifdef ARDUINO
#include <Arduino.h>
#else
#include <memory.h>
#endif

#include <assert.h>
#include <float.h>
#include <iostream>
#include <math.h>
#include <stdint.h>
#include <stdlib.h>

#ifndef assert
#define assert(x)                                                                                                                                                                                      \
    {                                                                                                                                                                                                  \
        if ((x) == false)                                                                                                                                                                              \
            __debugbreak();                                                                                                                                                                            \
    }
#endif
 
namespace Audinate { namespace ats {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INSTANCE MANAGEMENT
//

Ats::Ats()
{
    if (sizeof(mData) < sizeof(ats_t))
        std::cout << "Insufficient ATS mData - Need " << sizeof(ats_t) << std::endl;
    assert(sizeof(mData) >= sizeof(ats_t)); // Ensure hidden data allocation is sufficient
    memset(mData, 0, sizeof(ats_t));
}

Ats::~Ats()
{
    ats_t *p = (ats_t *)mData;
    if (p->data != nullptr)
        free(p->data);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GETS AND SIMPLE SETS
//

const Config *Ats::getConfig(Config *c)
{
    ats_t *p = (ats_t *)mData;
    if (c == nullptr)
        return &p->config;
    memcpy(c, &p->config, sizeof(Config));
    return c;
};

// int  atsGetIn(ats_t *p) { return p->in; }
// int  atsGetOut(ats_t *p) { return p->outN; }

int    Ats::getDepth() { return SUB(((ats_t *)mData)->in, ((ats_t *)mData)->outN); };
void   Ats::setDepth(int depth) { ((ats_t *)mData)->outN = MOD(((ats_t *)mData)->in - depth); }
double Ats::getRate() { return (double)(0x10000000) / ((ats_t *)mData)->step; }

bool Ats::setRate(double rate)
{
    ((ats_t *)mData)->step = ats_double_4f28u(1.0 / rate);
    return true;
}

uint32_t kth_smallest(uint32_t a[], int n, int k)
{
    int      i, j, l, m;
    uint32_t x, tmp;

    l = 0;
    m = n - 1;
    while (l < m) {
        x = a[k];
        i = l;
        j = m;
        do {
            while (a[i] < x)
                i++;
            while (x < a[j])
                j--;
            if (i <= j) {
                tmp  = a[i];
                a[i] = a[j];
                a[j] = tmp;
                i++;
                j--;
            }
        } while (i <= j);
        if (j < k)
            l = i;
        if (k < i)
            m = j;
    }
    return a[k];
}

uint32_t atsGetPosition(uint32_t *data, uint32_t offset, int N) // Filtering outliers and returning an estimate.
{
    uint32_t tmp[sizeof(((ats_t *)0)->pushOffset)/sizeof(uint32_t)];
    if (N > (int)(sizeof(((ats_t *)0)->pushOffset)/sizeof(uint32_t))) N = sizeof(((ats_t *)0)->pushOffset)/sizeof(uint32_t);
    for (int n = 0; n < N; n++)
        tmp[n] = data[n] - offset - (1 << 31);
    return kth_smallest(tmp, N, N - N/10 - 1) + offset + (1 << 31);
}

uint32_t atsPushOffset(ats_t *p)
{
    if (p->config.filterPush == 0)
        return p->in << (32 - ATS_BUFFER_SIZE_LOG2);
    return atsGetPosition(p->pushOffset, p->pushOffset[p->pushOffsetN], p->config.filterPush);
}

uint32_t atsPopOffset(ats_t *p)
{
    if (p->config.filterPop == 0)
        return p->outN << (32 - ATS_BUFFER_SIZE_LOG2);
    return atsGetPosition(p->popOffset, p->popOffset[p->popOffsetN], p->config.filterPop);
}

// Latency uses a bit more information to estimate, includes outlier removal (late calls) and relies on some estimate of period
float Ats::getLatency()
{
    ats_t *p       = (ats_t *)mData;
    float  latency = 0;
    int    offset  = atsPushOffset(p) - atsPopOffset(p); // Note that this is a wrapping int
    latency        = (float)offset * (float)ATS_BUFFER_SIZE / 4294967296.0F;
    if (latency < -1 * p->config.bufferSamples / 4)
        latency += p->config.bufferSamples;
    if (latency > 3 * p->config.bufferSamples / 4)
        latency -= p->config.bufferSamples;
    return latency;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SIMPLE ACCESS TO THE chrono
//
Chrono *Ats::chrono(Event index)
{
    assert(index >= 0 && index < EVENTS);
    if (index < 0 || index >= EVENTS)
        index = PUSH; // Return a sensible safe default
    return &((ats_t *)mData)->chrono[index];
}

void Ats::chronoReset(Event index)
{
    ats_t *p = (ats_t *)mData;
    if (index == EVENTS) {
        for (int n = 0; n < EVENTS; n++)
            chronoReset((Event)n);
        return;
    }
    if (index < 0 || index >= EVENTS)
        return;
    p->chrono[index].reset();
}

void Ats::chronoDefault(int bins, float T)
{
    ats_t *p = (ats_t *)mData;
    // Use the atsChrono method here as it will make the chrono if it does not exist
    this->chrono(PUSH)->config(0.000F, T, bins, DITHER,
                               "PUSH FUNCTION CALL PERIOD (s)"); // Expecting block calls <10ms
    this->chrono(POP)->config(0.000F, T, bins, DITHER,
                              "POP FUNCTION CALL PERIOD (s)"); //
    this->chrono(PUSH_RATE)->config(0, 5.0F/p->config.inRate, bins, DITHER, "PUSH AUDIO RAW PERIOD (s)");
    this->chrono(POP_RATE)->config (0, 5.0F/p->config.outRate,bins, DITHER, "POP AUDIO RAW PERIOD (s)"); 
    this->chrono(UNDER_RUN)->config(0.001F, 1000.0F, bins, DITHER | LOGX,
                                    "TIME BETWEEN UNDERRUNS (s)"); // 10s range
    this->chrono(UNDER_RUN_SIZE)->config(10, 1000, bins, DITHER | LOGX | COUNTER,
                                         "UNDER RUN SIZE (samples)"); // Up to 200 samples or nearly 5ms
    this->chrono(PUSH_EXEC)->config(0, T, bins, DITHER, "EXECUTION TIME OF PUSH (s)");
    this->chrono(POP_EXEC)->config(0, T, bins, DITHER, "EXECUTION TIME OF POP (s)");
    this->chrono(OFFSET)->config(-200, 200, bins, DITHER | COUNTER, "OFFSET FROM CONFIGURED RATE (ppm)");
    this->chrono(DEPTH)->config(0, 1000, bins, DITHER | COUNTER, "OBSERVED BUFFER DEPTH (input samples)");
    this->chrono(LATENCY)->config((float)(((ats_t *)mData)->config.trackTarget - 50), (float)(((ats_t *)mData)->config.trackTarget + 50), bins, DITHER | COUNTER, "ESTIMATED LATENCY (input samples)");
    this->chrono(TRACK)->config(1e-3F, 1e-1F, bins, DITHER | LOGX, "TRACK CONTROL PERIOD (s)");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MAIN CONFIGURATION CHECKS AND SETUP
//

bool Ats::config(Config *config)
{
    ats_t *mAts = (ats_t *)mData;
    if (mAts == nullptr || config == nullptr)
        return false;
    assert(((config->bufferSamples / 2) & config->bufferSamples) == 0); // Ensure this is a power of 2 - potentially a const

    if (mAts->configs == 0)
        mAts->step = 0x10000000;

    if (mAts->configs == 0 || mAts->config.bufferSamples != config->bufferSamples || mAts->config.channels != config->channels) {
        if (mAts->data != nullptr)
            free(mAts->data);
        mAts->data = (AtsData *)calloc(config->bufferSamples * config->channels, sizeof(AtsData));
        assert(mAts->data != nullptr); // Panic - this is a large memory allocation on embedded - better to fail here
        if (mAts->data == nullptr)
            return false;
        mAts->in        = 0;
        mAts->outN      = 0;
        mAts->outF      = 0;
        mAts->trackProp = 0;
        mAts->trackInt  = 0;
        mAts->trackT    = 0;
    }

    if (config->inRate <= 0)
        config->inRate = 1;
    if (config->outRate <= 0)
        config->outRate = 1;

    mAts->trackStep0 = ats_4f28u_one() + (int)((float)(config->inRate - config->outRate) / config->outRate * ats_4f28u_one() + 0.5);
    mAts->maxIntDivT = (int32_t)(4.294967296F * config->inRate * (1<<10));
    mAts->step       = mAts->trackStep0;

    if (config->filterPush > (int)(sizeof(mAts->pushOffset) / sizeof(uint32_t)))
        config->filterPush = sizeof(mAts->pushOffset) / sizeof(uint32_t);
    if (config->filterPop > (int)(sizeof(mAts->popOffset) / sizeof(uint32_t)))
        config->filterPop = sizeof(mAts->popOffset) / sizeof(uint32_t);
    mAts->pushOffsetN = 0;
    mAts->popOffsetN  = 0;
    memset(mAts->pushOffset, 0, sizeof(mAts->pushOffset));
    memset(mAts->popOffset, 0, sizeof(mAts->popOffset));

    memcpy(&mAts->config, config, sizeof(Config));
    mAts->configs++;

    this->chronoDefault(101); // Setup the default ranges in the Chronographs

    return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// THE CONTROL LOOP
//
// This code is robust over a wide range of noise conditions with minimal tuning and integrates time so can
// be called at any rate.  Suggest at least 10Hz and it will rate limit to 100Hz.  In most cases it will
// be called from the Push.
//

void Ats::atsTrack()
{
    ats_t *p = (ats_t *)mData;

    if (p->chrono[TRACK].sinceNs() < 10000000)
        return;
    p->chrono[TRACK].event();

    p->trackT     = 0.5E-9F * p->chrono[TRACK].diffNs() + 0.5F * p->trackT; // Mild smoothing
    float latency = getLatency();                                           // Latency
    float error   = ((float)p->config.trackTarget - latency);               // Error in samples

    if (p->config.trackRange > 0) {
        if (error > p->config.trackRange)
            p->in = MOD(p->in + (int)(error - p->config.trackRange + 0.5)); // Ensure change moves either in or out ahead in
        if (error < -p->config.trackRange)
            p->outN = MOD(p->outN + (int)(-error - p->config.trackRange + 0.5)); // the buffer so our Max filter updates
    }

    if (p->config.trackWarp > 0) // Warp the proportional to reduce noise
    {
        if (error < -p->config.trackWarp)
            error += 0.5F * p->config.trackWarp;
        else if (error > p->config.trackWarp)
            error -= 0.5F * p->config.trackWarp;
        else if (error > 0)
            error = 0.5F / p->config.trackWarp * error * error;
        else
            error = -0.5F / p->config.trackWarp * error * error;
        // x = -200:200; o=100; plot(x,(x<-o).*(x+o/2) + (abs(x)<=o).*(1/2/o*x.^2).*sign(x) + (x>o).*(x-o/2));
    }
    p->trackProp = p->config.trackKp * error;             // Proportional term in PPM
    p->trackInt += p->config.trackKi * error * p->trackT; // Time adjusted integral term in PPM
    p->trackOff = p->trackProp + p->trackInt;
    if (p->config.trackRate > 0) // Apply slew rate limiting if enabled
    {                            // Can significantly reduce sudden upsets if a thread is stalled
        float diff = p->trackOff - p->trackSlew;
        float slew = p->trackT * p->config.trackRate;
        if (diff > slew)
            p->trackSlew += slew;
        else if (diff < -slew)
            p->trackSlew -= slew;
        else
            p->trackSlew += diff;
    } else
        p->trackSlew = p->trackOff;

    // Update step for the new rate in ats_4f28u - adust in ppm about nominal rate
    p->step = p->trackStep0 - (int)(p->trackSlew / 1E6F * p->trackStep0 + 0.5);

    p->chrono[LATENCY].count((int)(latency + 0.5));
    p->chrono[DEPTH].count(getDepth());
    p->chrono[OFFSET].count((int)(p->trackSlew + 0.5));
}

void Ats::trackReset() // Reset the tracking state (integrator) and bump from the current
{                      // latency to get at the desired target.
    ats_t *p      = (ats_t *)mData;
    p->trackInt   = 0;
    p->trackSlew  = 0;
    p->step       = p->trackStep0;
    float latency = getLatency();                             // Latency
    float error   = ((float)p->config.trackTarget - latency); // Error in samples
    p->outN       = MOD(p->outN - (int)(error + 0.5));
    for (int n = 0; n < p->config.filterPop; n++)
        p->popOffset[n] -= ((int)error) << (32 - ATS_BUFFER_SIZE_LOG2);
    // We moved the Pop pointer, so adjust all of the values in the pop offset history
}

void Ats::trace(std::FILE *f)
{
    ats_t *p   = (ats_t *)mData;
    double now = 1E-9 * Chrono::nowNs();
    fprintf(
        f,
        "%11.3lf %8.2f %11.9lf %10u %10u %10u %10u %11.0f %11.0f %11.0f %6d %9d %9d\n",
        now,                           // 1  TIME
        getLatency(),                  // 2  LATENCY
        getRate(),                     // 3  RATE
        p->pushOffset[p->pushOffsetN], // 4  LAST RAW PUSH OFFSET
        atsPushOffset(p),              // 5  FILTERED PUSH OFFSET
        p->popOffset[p->popOffsetN],   // 6  LAST RAW POP OFFSET
        atsPopOffset(p),               // 7  FILTERED POP OFFSET
        p->trackProp * 1E3F,           // 8  PROPORTIONAL ADJUST ppb
        p->trackInt * 1E3F,            // 9  INTEGRAL     ADJUST ppb
        p->trackSlew * 1E3F,           // 10 SLEW LIMITED ADJUST ppb
        getDepth(),                    // 11 BUFFER DEPTH
        (int)p->chrono[PUSH].eventCount(),  // 12 PUSH EVENT
        (int)p->chrono[POP].eventCount());  // 13 POP EVENT COUNT 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MAIN PUSH AND POP
//

void Ats::push(int samples, int sampleStride, int channelStride, int32_t *data, int64_t callTime)
{
    ats_t *p = (ats_t *)mData;
    assert(p->configs > 0);
    assert(data!=nullptr);
    assert(samples>0);
    assert((sampleStride==0 && channelStride==0) || samples < p->config.bufferSamples); // Could have a miss longer than the buffer

    if (callTime<1000000000) callTime = Chrono::nowNs() - callTime;

    p->chrono[PUSH].event(callTime);
    p->chrono[PUSH_RATE].event(callTime,samples);
    p->chrono[PUSH_EXEC].restart(); // Restart the chrono used to calculate the time in this routine

    // Convert sample point and time to 0..2^32.
    if (p->config.filterPush) {
        uint32_t offset               = (uint32_t)((((uint64_t)p->in + samples) << (32 - ATS_BUFFER_SIZE_LOG2)) - (((callTime) * p->maxIntDivT) >> (10 + ATS_BUFFER_SIZE_LOG2)));
        p->pushOffsetN                = (p->pushOffsetN + 1) % p->config.filterPush;
        p->pushOffset[p->pushOffsetN] = offset;
    }

    if (!(p->config.mode & ATS_TRACKING_OFF))
        atsTrack(); // Update the tracking before pushing data so we record the lowest buffer depth

    for (int s = 0; s < samples; s++) {
        float *  dst = p->data + p->in * p->config.channels;
        int32_t *src = data + s * sampleStride;
        for (int c = 0; c < p->config.channels; c++) {
            *dst++ = (AtsData)*src;
            src += channelStride;
        };
        p->in = MOD(p->in + 1); // And move along
    }

    p->chrono[PUSH_EXEC].event(); // Record the execution time
}

void Ats::skip(int samples)
{
    int32_t zero = 0;
    push(samples, 0, 0, &zero);
}

void atsInterp(ats_t *p, int samples, int sample_stride, int channel_stride, AtsData *data);

void Ats::pop(int samples, int sampleStride, int channelStride, AtsData *dst, int64_t callTime)
{
    ats_t *p = (ats_t *)mData;
    assert(p->configs > 0);

    if (callTime<10000000000) callTime = Chrono::nowNs() - callTime;
        
    p->chrono[POP].event(callTime);
    p->chrono[POP_RATE].event(callTime,samples);
    p->chrono[POP_EXEC].restart();

    // Invariant based on first sample - as this is closest to what is about to be played out
    if (p->config.filterPop) {
        p->popOffsetN = (p->popOffsetN + 1) % p->config.filterPop;
        p->popOffset[p->popOffsetN]  = (uint32_t)( ( (uint64_t)p->outN<<(32-ATS_BUFFER_SIZE_LOG2)) +
                                                   (           p->outF>>(ATS_BUFFER_SIZE_LOG2-4))  -			// Include fractional part
                                                   (((callTime)*p->maxIntDivT)>>(10+ATS_BUFFER_SIZE_LOG2)) );
    }

    int need = ats_4f28u_advance(p->outF, p->step, samples); // Precise calc of required samples - how far outN will move
    int have = SUB(p->in, p->outN);                          // Work out how much we have
    if (need > have)                                         // We need to create some new samples
    {
        p->chrono[UNDER_RUN].event();
        p->chrono[UNDER_RUN_SIZE].count(need - have);
    }

    atsInterp(p, samples, sampleStride, channelStride, dst);

    p->chrono[POP_EXEC].event();
}

void Ats::pop(int samples, int sampleStride, int channelStride, int32_t *data, int64_t callTime)
{
    // NOTE THAT THIS IS AN INPLACE CONVERSION FLOAT -> INT   INTS are briefly 'invalid'
    // SHOULD CHECK HERE THAT AtsData == float - otherwise we are already fixed point
    pop(samples, sampleStride, channelStride, (AtsData *)data, callTime);
    for (int s = 0; s < samples; s++) {
        float *dst = (float *)data + s * sampleStride;
        for (int c = 0; c < getConfig()->channels; c++) {
            // 0x7FFE0000 is a safe saturation if the audio is truncated to 16 bit (with dither)
            if (*dst > (float)0x7FFE0000)
                *dst = (float)0x7FFE0000;
            else if (*dst < -(float)0x80000000)
                *dst = -(float)0x80000000;
            *((int32_t *)dst) = (int32_t)*dst;
            dst += channelStride;
        }
    }
}

void atsInterpHold(ats_t *p, int samples, int sampleStride, int channelStride, AtsData *data);
void atsInterpLinear(ats_t *p, int samples, int sampleStride, int channelStride, AtsData *data);
void atsInterpSpline3(ats_t *p, int samples, int sampleStride, int channelStride, AtsData *data);
void atsInterpSpline5(ats_t *p, int samples, int sampleStride, int channelStride, AtsData *data);

void atsInterp(ats_t *p, int samples, int sample_stride, int channel_stride, AtsData *data)
{
    switch (p->config.mode & ATS_INTERP_MASK) {
    case ATS_INTERP_HOLD:
        atsInterpHold(p, samples, sample_stride, channel_stride, data);
        break;
    case ATS_INTERP_LINEAR:
        atsInterpLinear(p, samples, sample_stride, channel_stride, data);
        break;
    case ATS_INTERP_SPLINE3:
        atsInterpSpline3(p, samples, sample_stride, channel_stride, data);
        break;
    case ATS_INTERP_SPLINE5:
        atsInterpSpline5(p, samples, sample_stride, channel_stride, data);
        break;
    default:
        assert(0);
    }
}

void Ats::histogram(Event event, Histogram *h) { ((ats_t *)mData)->chrono[event].histogram(h); }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Versioning

const char * Ats::versionFull() { return ATS_CORE_GIT_COMPONENT_TAG_VERSION_FULL; }
const char * Ats::versionHash() { return ATS_CORE_GIT_HASH_SHORT; }
unsigned int Ats::versionMajor() { return ATS_CORE_GIT_VERSION_MAJOR; }
unsigned int Ats::versionMinor() { return ATS_CORE_GIT_VERSION_MINOR; }
unsigned int Ats::versionPatch() { return ATS_CORE_GIT_VERSION_PATCH; }
const char * Ats::versionSuffix() { return ATS_CORE_GIT_VERSION_SUFFIX; }

}} // namespace Audinate::ats

//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//