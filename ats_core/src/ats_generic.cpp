//
// AUDIO TEMPORAL STRETCHER CODE LICENSE
//
// PERMISION NOTICE
//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//
//
// 1.   Subject to the terms and conditions of this Licence, Audinate hereby grants you a worldwide, non-exclusive, 
//      no-charge, royalty free licence to copy, modify, merge, publish, redistribute, sublicense, and/or sell the 
//      Software, provided always that the following conditions are met: 
//      1.1.    the Software must accompany, or be incorporated in a licensed Audinate product, solution or offering 
//              or be used in a product, solution or offering which requires the use of another licensed Audinate 
//              product, solution or offering. The Software is not for use as a standalone product without any 
//              reference to Audinate’s products;
//      1.2.    the Software is provided as part of example code and as guidance material only without any warranty 
//              or expectation of performance, compatibility, support, updates or security; and
//      1.3.    the above copyright notice and this License must be included in all copies or substantial portions 
//              of the Software, and all derivative works of the Software, unless the copies or derivative works are 
//              solely in the form of machine-executable object code generated by the source language processor.
//
// 2.   TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
//      XPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
//      PURPOSE AND NONINFRINGEMENT. 
//
// 3.   TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL AUDINATE BE LIABLE ON ANY LEGAL THEORY 
//      (INCLUDING, WITHOUT LIMITATION, IN AN ACTION FOR BREACH OF CONTRACT, NEGLIGENCE OR OTHERWISE) FOR ANY CLAIM, 
//      LOSS, DAMAGES OR OTHER LIABILITY HOWSOEVER INCURRED.  WITHOUT LIMITING THE SCOPE OF THE PREVIOUS SENTENCE THE 
//      EXCLUSION OF LIABILITY SHALL INCLUDE: LOSS OF PRODUCTION OR OPERATION TIME, LOSS, DAMAGE OR CORRUPTION OF 
//      DATA OR RECORDS; OR LOSS OF ANTICIPATED SAVINGS, OPPORTUNITY, REVENUE, PROFIT OR GOODWILL, OR OTHER ECONOMIC 
//      LOSS; OR ANY SPECIAL, INCIDENTAL, INDIRECT, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES, ARISING OUT OF OR 
//      IN CONNECTION WITH THIS AGREEMENT, ACCESS OF THE SOFTWARE OR ANY OTHER DEALINGS WITH THE SOFTWARE, EVEN IF 
//      AUDINATE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH CLAIM, LOSS, DAMAGES OR OTHER LIABILITY.
//
// 4.   APPLICABLE LEGISLATION SUCH AS THE AUSTRALIAN CONSUMER LAW MAY APPLY REPRESENTATIONS, WARRANTIES, OR CONDITIONS, 
//      OR IMPOSES OBLIGATIONS OR LIABILITY ON AUDINATE THAT CANNOT BE EXCLUDED, RESTRICTED OR MODIFIED TO THE FULL 
//      EXTENT SET OUT IN THE EXPRESS TERMS OF THIS CLAUSE ABOVE "CONSUMER GUARANTEES".  TO THE EXTENT THAT SUCH CONSUMER 
//      GUARANTEES CONTINUE TO APPLY, THEN TO THE FULL EXTENT PERMITTED BY THE APPLICABLE LEGISLATION, THE LIABILITY OF 
//      AUDINATE UNDER THE RELEVANT CONSUMER GUARANTEE IS LIMITED (WHERE PERMITTED AT AUDINATE’S OPTION) TO ONE OF 
//      FOLLOWING REMEDIES OR SUBSTANTIALLY EQUIVALENT REMEDIES:
//      4.1.    THE REPLACEMENT OF THE SOFTWARE, THE SUPPLY OF EQUIVALENT SOFTWARE, OR SUPPLYING RELEVANT SERVICES AGAIN;
//      4.2.    THE REPAIR OF THE SOFTWARE;
//      4.3.    THE PAYMENT OF THE COST OF REPLACING THE SOFTWARE, OF ACQUIRING EQUIVALENT SOFTWARE, HAVING THE RELEVANT 
//              SERVICES SUPPLIED AGAIN, OR HAVING THE SOFTWARE REPAIRED.
//
// 5.   This License does not grant any permissions or rights to use the trade marks (whether registered or unregistered), 
//      the trade names, or product names of Audinate. 
//
// 6.   If you choose to redistribute or sell the Software you may elect to offer support, maintenance, warranties, 
//      indemnities or other liability obligations or rights consistent with this License. However, you may only act on 
//      your own behalf and must not bind Audinate. You agree to indemnify and hold harmless Audinate, and its affiliates 
//      form any liability claimed or incurred by reason of your offering or accepting any additional warranty or additional 
//      liability. 
//
// ats_generic.cpp
//

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// FLESH OUT THE PUSH AND POP METHODS
//
// These are the generic functions for doing a lot of the work.  It these need to be platform specific,
// then they can be branched out into other files.  Can move this later with these becoming the generics.
//
// These are only called from within another ats method, so do not need to be as aggressive on asserts.
//
// Note that these will be called once with samples=0 and potentially an deleted memory block each time
// that the ATS is reconfigured.  This allows the function to setup and re-initialize all necessary state
//

#include "ats.h"
#include "ats_t.h"
#ifdef ARDUINO
#include <Arduino.h>
#else
#include <memory.h>
#endif
#include <assert.h>
#include <float.h>
#include <stdint.h>
#include <stdlib.h>

#ifndef assert
#define assert(x)                                                                                                                                                                                      \
    {                                                                                                                                                                                                  \
        if ((x) == false)                                                                                                                                                                              \
            __debugbreak();                                                                                                                                                                            \
    }
#endif

namespace Audinate { namespace ats {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// FIXED POINT NATIVE
//
// Some functions to work with fixed point representations.  Not fully sorted yet, but feasible.
//

typedef float   AtsCoeff;
inline AtsData  atsDataMulCoeff(AtsData a, AtsCoeff b) { return a * b; };
inline AtsData  atsDataMul8f24u(AtsData a, ats_4f28u b) { return (AtsData)(a * ats_4f28u_float(b)); };
inline AtsCoeff atsCoeffMulCoeff(AtsCoeff a, AtsCoeff b) { return a * b; };
inline AtsCoeff ats4f28uCoeff(ats_4f28u a) { return (AtsCoeff)ats_4f28u_float(a); };

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// POP METHODS
//
// These are selected via the mode flag of the config block set during the setup.  Here we are mostly dealing
// with the specifics of the interpolation, with call outs to handle aspects of the fade and extrapolation.
//

inline void atsInterpAdvance(ats_t *p)   // Helper function to advance one increment of
{                                        // the target and the output
    ats_4f28u inc = p->outF + p->step;   // Accumulate the fractional part
    p->outF       = ats_4f28u_frac(inc); // Grab off the fraction
    inc           = ats_4f28u_int(inc);  // Grab off the integer
    p->outN       = MOD(p->outN + inc);  // Modulo bufferSize the increment
}

void atsInterpHold(ats_t *p, int samples, int sampleStride, int channelStride, AtsData *data)
{
    for (int s = 0; s < samples; s++) {
        AtsData *p0 = p->data + p->outN * p->config.channels;
        for (int c = 0; c < p->config.channels; c++) {
            data[sampleStride * s + channelStride * c] = *p0;
            *p0++                                      = 0;
        }
        atsInterpAdvance(p);
    }
}

void atsInterpLinear(ats_t *p, int samples, int sampleStride, int channelStride, AtsData *data) // Inherent delay of one sample
{
    for (int s = 0; s < samples; s++) {
        AtsData *p0 = p->data + MOD(p->outN - 1) * p->config.channels;
        AtsData *p1 = p->data + p->outN * p->config.channels;
        AtsCoeff f1 = ats4f28uCoeff(p->outF);
        AtsCoeff f0 = ats4f28uCoeff(ats_4f28u_one() - p->outF);

        for (int c = 0; c < p->config.channels; c++) {
            data[sampleStride * s + channelStride * c] = atsDataMulCoeff(*p0, f0) + atsDataMulCoeff(*p1++, f1);
            *p0++                                      = 0;
        }
        atsInterpAdvance(p);
    }
}

void atsInterpSpline3(ats_t *p, int samples, int sampleStride, int channelStride, AtsData *data)
{
    for (int s = 0; s < samples; s++) {
        AtsData *p0 = p->data + MOD(p->outN - 3) * p->config.channels;
        AtsData *p1 = p->data + MOD(p->outN - 2) * p->config.channels;
        AtsData *p2 = p->data + MOD(p->outN - 1) * p->config.channels;
        AtsData *p3 = p->data + p->outN * p->config.channels;

        AtsCoeff x1 = ats4f28uCoeff(p->outF);
        AtsCoeff x2 = atsCoeffMulCoeff(x1, x1);
        AtsCoeff x3 = atsCoeffMulCoeff(x2, x1);

        AtsCoeff f0 = -0.5F * x3 + x2 + -0.5F * x1;
        AtsCoeff f1 = 1.5F * x3 + -2.5F * x2 + 1.0F;
        AtsCoeff f2 = -1.5F * x3 + 2.0F * x2 + 0.5F * x1;
        AtsCoeff f3 = 0.5F * x3 + -0.5F * x2;

        for (int c = 0; c < p->config.channels; c++) {
            data[sampleStride * s + channelStride * c] = atsDataMulCoeff(*p0, f0) + atsDataMulCoeff(*p1++, f1) + atsDataMulCoeff(*p2++, f2) + atsDataMulCoeff(*p3++, f3);
            *p0++                                      = 0;
        }
        atsInterpAdvance(p);
    }
}

void atsInterpSpline5(ats_t *p, int samples, int sampleStride, int channelStride, AtsData *data)
{
    for (int s = 0; s < samples; s++) {
        AtsData *p0 = p->data + MOD(p->outN - 5) * p->config.channels;
        AtsData *p1 = p->data + MOD(p->outN - 4) * p->config.channels;
        AtsData *p2 = p->data + MOD(p->outN - 3) * p->config.channels;
        AtsData *p3 = p->data + MOD(p->outN - 2) * p->config.channels;
        AtsData *p4 = p->data + MOD(p->outN - 1) * p->config.channels;
        AtsData *p5 = p->data + p->outN * p->config.channels;

        AtsCoeff x1 = ats4f28uCoeff(p->outF);
        AtsCoeff x2 = atsCoeffMulCoeff(x1, x1);
        AtsCoeff x3 = atsCoeffMulCoeff(x2, x1);
        AtsCoeff x4 = atsCoeffMulCoeff(x3, x1);
        AtsCoeff x5 = atsCoeffMulCoeff(x4, x1);

        AtsCoeff f0 = -3.0F / 108 * x5 + 12.0F / 108 * x4 + -9.0F / 108 * x3 + -12.0F / 108 * x2 + 12.0F / 108 * x1;
        AtsCoeff f1 = 13.0F / 108 * x5 + -46.0F / 108 * x4 + 9.0F / 108 * x3 + 100.0F / 108 * x2 + -76.0F / 108 * x1;
        AtsCoeff f2 = -24.0F / 108 * x5 + 69.0F / 108 * x4 + 36.0F / 108 * x3 + -177.0F / 108 * x2 + -12.0F / 108 * x1 + 1.0F;
        AtsCoeff f3 = 24.0F / 108 * x5 + -51.0F / 108 * x4 + -72.0F / 108 * x3 + 105.0F / 108 * x2 + 102.0F / 108 * x1;
        AtsCoeff f4 = -13.0F / 108 * x5 + 19.0F / 108 * x4 + 45.0F / 108 * x3 + -19.0F / 108 * x2 + -32.0F / 108 * x1;
        AtsCoeff f5 = 3.0F / 108 * x5 + -3.0F / 108 * x4 + -9.0F / 108 * x3 + 3.0F / 108 * x2 + 6.0F / 108 * x1;

        for (int c = 0; c < p->config.channels; c++) {
            data[sampleStride * s + channelStride * c] =
                atsDataMulCoeff(*p0, f0) + atsDataMulCoeff(*p1++, f1) + atsDataMulCoeff(*p2++, f2) + atsDataMulCoeff(*p3++, f3) + atsDataMulCoeff(*p4++, f4) + atsDataMulCoeff(*p5++, f5);
            *p0++ = 0;
        }
        atsInterpAdvance(p);
    }
}

}} // namespace Audinate::ats

//
// Copyright © 2022 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved. 
//